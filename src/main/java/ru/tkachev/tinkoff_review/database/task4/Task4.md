# Database - Задание №4

### План запроса, как его получить и как анализировать<br/><br/>

Выполняя любой полученный запрос, PostgreSQL разрабатывает для него план запроса. 
Выбор правильного плана, соответствующего структуре запроса и характеристикам данным, 
крайне важен для хорошей производительности, поэтому в системе работает сложный 
планировщик, задача которого — подобрать хороший план. Узнать, какой план был выбран 
для какого-либо запроса, можно с помощью команды `EXPLAIN`.

Структура плана запроса представляет собой дерево узлов плана. 
Узлы на нижнем уровне дерева — это узлы сканирования, которые возвращают 
необработанные данные таблицы. Разным типам доступа к таблице соответствуют разные 
узлы: последовательное сканирование, сканирование индекса и 
сканирование битовой карты. Источниками строк могут быть не только таблицы, 
но и например, предложения `VALUES` и функции, возвращающие множества во `FROM`, 
и они представляются отдельными типами узлов сканирования. Если запрос требует 
объединения, агрегатных вычислений, сортировки или других операций с исходными 
строками, над узлами сканирования появляются узлы, обозначающие эти операции. 
И так как обычно операции могут выполняться разными способами, на этом уровне 
тоже могут быть узлы разных типов. В выводе команды `EXPLAIN` для каждого узла 
в дереве плана отводится одна строка, где показывается базовый тип узла плюс 
оценка стоимости выполнения данного узла, которую сделал для него планировщик. 
Если для узла выводятся дополнительные свойства, в вывод могут добавляться 
дополнительные строки, с отступом от основной информации узла. 
В самой первой строке (основной строке самого верхнего узла) выводится 
общая стоимость выполнения для всего плана; именно это значение планировщик 
старается минимизировать.

```sql
EXPLAIN SELECT * FROM tenk1;

                         QUERY PLAN
-------------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..458.00 rows=10000 width=244)
```

Запрос не содержит предложения `WHERE`, поэтому он должен просканировать все строки 
таблицы, так что планировщик выбрал план простого последовательного сканирования. 
Числа, перечисленные в скобках (слева направо), имеют следующий смысл:

* Приблизительная стоимость запуска. Это время, которое проходит, прежде чем начнётся
этап вывода данных, например для сортирующего узла это время сортировки.

* Приблизительная общая стоимость. Она вычисляется в предположении, что узел плана 
выполняется до конца, то есть возвращает все доступные строки. 
На практике родительский узел может досрочно прекратить чтение строк дочернего.

* Ожидаемое число строк, которое должен вывести этот узел плана. 
При этом так же предполагается, что узел выполняется до конца.

* Ожидаемый средний размер строк, выводимых этим узлом плана (в байтах).

Стоимость может измеряться в произвольных единицах, определяемых параметрами 
планировщика. Традиционно единицей стоимости считается операция чтения страницы 
с диска, то есть `seq_page_cost` обычно равен 1.0, а другие параметры задаётся относительно него.

Стоимость узла верхнего уровня включает стоимость всех его потомков. 
Также важно осознавать, что эта стоимость отражает только те факторы, 
которые учитывает планировщик. В частности, она не зависит от времени, 
необходимого для передачи результирующих строк клиенту, хотя оно может составлять 
значительную часть общего времени выполнения запроса. Тем не менее планировщик 
игнорирует эту величину, так как он всё равно не сможет изменить её, выбрав другой план.

Значение `rows` здесь имеет особенность — оно выражает не число строк, 
обработанных или просканированных узлом плана, а число строк, выданных этим узлом. 
Часто оно окажется меньше числа просканированных строк в результате применённой 
к узлу фильтрации по условиям `WHERE`. В идеале, на верхнем уровне это значение будет 
приблизительно равно числу строк, которое фактически возвращает, 
изменяет или удаляет запрос.

```sql
EXPLAIN SELECT * FROM tenk1 WHERE unique1 < 7000;

                             QUERY PLAN
------------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..483.00 rows=7001 width=244)
   Filter: (unique1 < 7000)
```

В выводе `EXPLAIN` показано, что условие `WHERE` применено как «фильтр» к узлу плана 
`Seq Scan` (последовательное сканирование). Это означает, что узел плана проверяет 
это условие для каждого просканированного им узла и выводит только те строки, 
которые удовлетворяют ему. Предложение `WHERE` повлияло на оценку числа выходных строк.
Однако при сканировании потребуется прочитать все 10000 строк, поэтому общая 
стоимость не уменьшилась. На деле она даже немного увеличилась 
(на `10000 * cpu_operator_cost`), отражая дополнительное время, которое 
потребуется процессору на проверку условия `WHERE`.

```sql
EXPLAIN SELECT * FROM tenk1 WHERE unique1 < 100;

                                  QUERY PLAN
------------------------------------------------------------------------------
 Bitmap Heap Scan on tenk1  (cost=5.07..229.20 rows=101 width=244)
   Recheck Cond: (unique1 < 100)
   ->  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 rows=101 width=0)
```

В данном случае планировщик используется план из двух этапов: сначала дочерний узел
плана просматривает индекс и находит в нём адреса строк, соответствующих условию 
индекса, а затем верхний узел собственно выбирает эти строки из таблицы. 
Выбирать строки по отдельности гораздо дороже, чем просто читать их последовательно,
но так как читать придётся не все страницы таблицы, это всё равно будет дешевле, 
чем сканировать всю таблицу. Использование двух уровней плана объясняется тем, 
что верхний узел сортирует адреса строк, выбранных из индекса, в физическом порядке,
прежде чем читать, чтобы снизить стоимость отдельных чтений. 
Слово `bitmap` (битовая карта) в имени узла обозначает механизм, выполняющий сортировку.

```sql
EXPLAIN SELECT * FROM tenk1 WHERE unique1 < 100 AND stringu1 = 'xxx';

                                  QUERY PLAN
------------------------------------------------------------------------------
 Bitmap Heap Scan on tenk1  (cost=5.04..229.43 rows=1 width=244)
   Recheck Cond: (unique1 < 100)
   Filter: (stringu1 = 'xxx'::name)
   ->  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 rows=101 width=0)
         Index Cond: (unique1 < 100)
```

Добавленное условие `stringu1 = 'xxx'` уменьшает оценку числа результирующих строк, 
но не стоимость запроса, так как просматриваться будет тот же набор строк, 
что и раньше. Условие на `stringu1` не добавляется в качестве условия индекса, 
так как индекс построен только по столбцу `unique1`. Вместо этого оно применяется 
как фильтр к строкам, полученным по индексу. В результате стоимость даже немного 
увеличилась, отражая добавление этой проверки.

В некоторых случаях планировщик предпочтёт «простой» план сканирования индекса:

```sql
EXPLAIN SELECT * FROM tenk1 WHERE unique1 = 42;

                                 QUERY PLAN
-----------------------------------------------------------------------------
 Index Scan using tenk1_unique1 on tenk1  (cost=0.29..8.30 rows=1 width=244)
   Index Cond: (unique1 = 42)
```

В плане такого типа строки таблицы выбираются в порядке индекса, 
в результате чего чтение их обходится дороже, но так как их немного, 
дополнительно сортировать положения строк не стоит. Этот тип плана 
часто встречается в запросах, которые выбирают всего одну строку. 
Также он часто задействуется там, где условие `ORDER BY` соответствует порядку 
индекса, так как в этих случаях для выполнения `ORDER BY` не требуется 
дополнительный шаг сортировки. В этом примере добавленная конструкция 
`ORDER BY unique1` будет использовать тот же план, потому что индекс уже неявно 
обеспечивает нужный порядок.

Планировщик может обработать конструкцию `ORDER BY` несколькими способами. 
Предыдущий пример показывает, что нужный порядок может быть получен неявным образом.
Также планировщик может задействовать явную операцию `Sort`:

```sql
EXPLAIN SELECT * FROM tenk1 ORDER BY unique1;
                            QUERY PLAN
-------------------------------------------------------------------
 Sort  (cost=1109.39..1134.39 rows=10000 width=244)
   Sort Key: unique1
   ->  Seq Scan on tenk1  (cost=0.00..445.00 rows=10000 width=244)
```

Если подплан гарантирует сортировку по префиксу заданных ключей сортировки, 
планировщик может применить операцию `Incremental sort` (инкрементальную сортировку):

```sql
EXPLAIN SELECT * FROM tenk1 ORDER BY four, ten LIMIT 100;
QUERY PLAN
------------------------------------------------------------------------------------------------------
 Limit  (cost=521.06..538.05 rows=100 width=244)
   ->  Incremental Sort  (cost=521.06..2220.95 rows=10000 width=244)
         Sort Key: four, ten
         Presorted Key: four
         ->  Index Scan using index_tenk1_on_four on tenk1  (cost=0.29..1510.08 rows=10000 width=244)
```

С инкрементальной сортировкой, в отличие от обычной, кортежи могут выдаваться 
до завершения сортировки всего результата, это в частности позволяет 
оптимизировать запросы с `LIMIT`. Кроме того, для инкрементальной сортировки может 
потребоваться меньше памяти, вследствие чего уменьшается вероятность вытеснения 
сортируемых данных на диск, но с другой стороны, требуется разделять результирующее 
множество на несколько частей, что влечёт дополнительные накладные расходы.

Если в таблице есть отдельные индексы по разным столбцам, фигурирующим в `WHERE`, 
планировщик может выбрать сочетание этих индексов (с `AND` и `OR`):

```sql
EXPLAIN SELECT * FROM tenk1 WHERE unique1 < 100 AND unique2 > 9000;

                                     QUERY PLAN
-------------------------------------------------------------------------------------
 Bitmap Heap Scan on tenk1  (cost=25.08..60.21 rows=10 width=244)
   Recheck Cond: ((unique1 < 100) AND (unique2 > 9000))
   ->  BitmapAnd  (cost=25.08..25.08 rows=10 width=0)
         ->  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 rows=101 width=0)
               Index Cond: (unique1 < 100)
         ->  Bitmap Index Scan on tenk1_unique2  (cost=0.00..19.78 rows=999 width=0)
               Index Cond: (unique2 > 9000)
```

Но для этого потребуется обойти оба индекса, так что это не обязательно будет 
выгоднее, чем просто просмотреть один индекс, а второе условие обработать как фильтр.

Следующий пример иллюстрирует эффекты `LIMIT`:

```sql
EXPLAIN SELECT * FROM tenk1 WHERE unique1 < 100 AND unique2 > 9000 LIMIT 2;

                                     QUERY PLAN
-------------------------------------------------------------------------------------
 Limit  (cost=0.29..14.48 rows=2 width=244)
   ->  Index Scan using tenk1_unique2 on tenk1  (cost=0.29..71.27 rows=10 width=244)
         Index Cond: (unique2 > 9000)
         Filter: (unique1 < 100)
```

Общая стоимость и число строк для узла `Index Scan` рассчитываются в предположении, 
что он будет выполняться полностью. Однако узел `Limit` должен остановиться, 
получив только пятую часть всех строк, так что его стоимость будет составлять одну 
пятую от вычисленной ранее, и это и будет итоговой оценкой стоимости запроса. 
С другой стороны, планировщик мог бы просто добавить в предыдущий план узел `Limit`,
но это не избавило бы от затрат на запуск сканирования битовой карты, а значит, 
общая стоимость была бы выше 25 единиц.

Точность оценок планировщика можно проверить, используя команду `EXPLAIN` 
с параметром `ANALYZE`. С этим параметром `EXPLAIN` на самом деле выполняет запрос,
а затем выводит фактическое число строк и время выполнения, накопленное в каждом 
узле плана, вместе с теми же оценками, что выдаёт обычная команда `EXPLAIN`.

```sql
EXPLAIN ANALYZE SELECT *
FROM tenk1 t1, tenk2 t2
WHERE t1.unique1 < 10 AND t1.unique2 = t2.unique2;

                                                           QUERY PLAN
-------------------------------------------------------------------​--------------------------------------------------------------
 Nested Loop  (cost=4.65..118.62 rows=10 width=488) (actual time=0.128..0.377 rows=10 loops=1)
   ->  Bitmap Heap Scan on tenk1 t1  (cost=4.36..39.47 rows=10 width=244) (actual time=0.057..0.121 rows=10 loops=1)
         Recheck Cond: (unique1 < 10)
         ->  Bitmap Index Scan on tenk1_unique1  (cost=0.00..4.36 rows=10 width=0) (actual time=0.024..0.024 rows=10 loops=1)
               Index Cond: (unique1 < 10)
   ->  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.29..7.91 rows=1 width=244) (actual time=0.021..0.022 rows=1 loops=10)
         Index Cond: (unique2 = t1.unique2)
 Planning time: 0.181 ms
 Execution time: 0.501 ms
```

Значения `actual time` (фактическое время) приводятся в миллисекундах, 
тогда как оценки `cost` (стоимость) выражаются в произвольных единицах, 
так что они вряд ли совпадут. Обычно важнее определить, насколько приблизительная 
оценка числа строк близка к действительности.

В некоторых планах запросов некоторый внутренний узел может выполняться неоднократно.
Например, внутреннее сканирование индекса будет выполняться для каждой внешней 
строки во вложенном цикле верхнего уровня. В таких случаях значение `loops` (циклы) 
показывает, сколько всего раз выполнялся этот узел, а фактическое время и число 
строк вычисляется как среднее по всем итерациям. Это делается для того, чтобы 
полученные значения можно было сравнить с выводимыми приблизительными оценками. 
Чтобы получить общее время, затраченное на выполнение узла, время одной итерации 
нужно умножить на значение `loops`. В показанном выше примере мы потратили 
в общей сложности 0.220 мс на сканирование индекса в `tenk2`.

В ряде случаев `EXPLAIN ANALYZE` выводит дополнительную статистику по выполнению, 
включающую не только время выполнения узлов и число строк. 
Для узлов `Sort` и `Hash`, например выводится следующая информация:

```sql
EXPLAIN ANALYZE SELECT *
FROM tenk1 t1, tenk2 t2
WHERE t1.unique1 < 100 AND t1.unique2 = t2.unique2 ORDER BY t1.fivethous;

                                                                 QUERY PLAN
--------------------------------------------------------------------------------------------------------------------------------------​------
 Sort  (cost=717.34..717.59 rows=101 width=488) (actual time=7.761..7.774 rows=100 loops=1)
   Sort Key: t1.fivethous
   Sort Method: quicksort  Memory: 77kB
   ->  Hash Join  (cost=230.47..713.98 rows=101 width=488) (actual time=0.711..7.427 rows=100 loops=1)
         Hash Cond: (t2.unique2 = t1.unique2)
         ->  Seq Scan on tenk2 t2  (cost=0.00..445.00 rows=10000 width=244) (actual time=0.007..2.583 rows=10000 loops=1)
         ->  Hash  (cost=229.20..229.20 rows=101 width=244) (actual time=0.659..0.659 rows=100 loops=1)
               Buckets: 1024  Batches: 1  Memory Usage: 28kB
               ->  Bitmap Heap Scan on tenk1 t1  (cost=5.07..229.20 rows=101 width=244) (actual time=0.080..0.526 rows=100 loops=1)
                     Recheck Cond: (unique1 < 100)
                     ->  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 rows=101 width=0) (actual time=0.049..0.049 rows=100 loops=1)
                           Index Cond: (unique1 < 100)
 Planning time: 0.194 ms
 Execution time: 8.008 ms
```

Для узла `Sort` показывается использованный метод и место сортировки 
(в памяти или на диске), а также задействованный объём памяти. 
Для узла `Hash` выводится число групп и пакетов хеша, а также максимальный объём, 
который заняла в памяти хеш-таблица. Если число пакетов больше одного, 
часть хеш-таблицы будет выгружаться на диск и занимать какое-то пространство, 
но его объём здесь не показывается.

Другая полезная дополнительная информация — число строк, удалённых условием фильтра:

```sql
EXPLAIN ANALYZE SELECT * FROM tenk1 WHERE ten < 7;

                                               QUERY PLAN
---------------------------------------------------------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..483.00 rows=7000 width=244) (actual time=0.016..5.107 rows=7000 loops=1)
   Filter: (ten < 7)
   Rows Removed by Filter: 3000
 Planning time: 0.083 ms
 Execution time: 5.905 ms
```

Эти значения могут быть особенно ценны для условий фильтра, 
применённых к узлам соединения. Строка `Rows Removed` выводится, только когда 
условие фильтра отбрасывает минимум одну просканированную строку или потенциальную 
пару соединения, если это узел соединения.

`EXPLAIN ANALYZE` действительно выполняет запрос, хотя его результаты могут 
не показываться, а заменяться выводом команды `EXPLAIN`. Поэтому при таком анализе 
возможны побочные эффекты. Если вы хотите проанализировать запрос, изменяющий данные,
но при этом сохранить прежние данные таблицы, вы можете откатить транзакцию 
после запроса:

```sql
BEGIN;

EXPLAIN ANALYZE UPDATE tenk1 SET hundred = hundred + 1 WHERE unique1 < 100;

                                                           QUERY PLAN
-------------------------------------------------------------------​-------------------------------------------------------------
 Update on tenk1  (cost=5.08..230.08 rows=0 width=0) (actual time=3.791..3.792 rows=0 loops=1)
   ->  Bitmap Heap Scan on tenk1  (cost=5.08..230.08 rows=102 width=10) (actual time=0.069..0.513 rows=100 loops=1)
         Recheck Cond: (unique1 < 100)
         Heap Blocks: exact=90
         ->  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.05 rows=102 width=0) (actual time=0.036..0.037 rows=300 loops=1)
               Index Cond: (unique1 < 100)
 Planning Time: 0.113 ms
 Execution Time: 3.850 ms

ROLLBACK;
```

Как показано в этом примере, когда выполняется команда `INSERT`, `UPDATE` или `DELETE`, 
собственно изменение данных в таблице происходит в узле верхнего уровня 
`Insert`, `Update` или `Delete`. Узлы плана более низких уровней выполняют 
работу по нахождению старых строк и/или вычислению новых данных. 
Поэтому вверху мы видим тот же тип сканирования битовой карты, что и раньше, 
только теперь его вывод подаётся узлу `Update`, который сохраняет изменённые строки.
Стоит отметить, что узел, изменяющий данные, может выполняться значительное время 
(в данном случае это составляет львиную часть всего времени), но планировщик не 
учитывает эту работу в оценке общей стоимости. Это связано с тем, что эта работа 
будет одинаковой при любом правильном плане запроса, и поэтому на выбор плана она 
не влияет.

Время выполнения, измеренное командой `EXPLAIN ANALYZE`, может значительно 
отличаться от времени выполнения того же запроса в обычном режиме.
Тому есть две основных причины. Во-первых, так как при анализе никакие строки 
результата не передаются клиенту, время ввода/вывода и передачи по сети не 
учитывается. Во-вторых, может быть существенной дополнительная нагрузка, 
связанная с функциями измерений `EXPLAIN ANALYZE`, особенно в системах, 
где вызов `gettimeofday()` выполняется медленно. Для измерения этой нагрузки можно 
воспользоваться утилитой `pg_test_timing`.

Результаты `EXPLAIN` не следует распространять на ситуации, значительно 
отличающиеся от тех, в которых вы проводите тестирование. В частности, 
не следует полагать, что выводы, полученные для игрушечной таблицы, 
будут применимы и для настоящих больших таблиц. Оценки стоимости нелинейны и 
планировщик может выбирать разные планы в зависимости от размера таблицы. 
Например, в крайнем случае вся таблица может уместиться в одну страницу диска, 
и тогда вы почти наверняка получите план последовательного сканирования, 
независимо от того, есть у неё и индексы или нет. Планировщик понимает, 
что для обработки таблицы ему в любом случае потребуется прочитать одну страницу,
так что нет никакого смысла обращаться к ещё одной странице за индексом.

Бывает, что фактическое и приближённо оценённое значения не совпадают, 
но в этом нет ничего плохого. Например, это возможно, когда выполнение плана 
узла прекращается преждевременно из-за указания `LIMIT` или подобного эффекта.
