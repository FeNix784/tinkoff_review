# Collections - Задание №2

### Сравнить ArrayList и LinkedList по памяти и времени для различных вставок<br/><br/>

### Array

Массив, для которого наперёд известно число элементов.  В нём на каждый объект хранится ссылка: 4 (8) байт (в скобках значение для 64-битной JVM), кроме того хранится длина массива — int, 4 байта, и дескриптор объекта — 8 (16) байт. Вдобавок каждый объект выравнивается по 8 байтам из-за чего массивы с чётным числом элементов на 32bit теряют по 4 байта. Итог: по 4 (8) байт на объект плюс постоянная от 12 до 24 байт. Пустой массив занимает 16 (24) байт.

### ArrayList

Массив выделяется с запасом (по умолчанию на 10 элементов) и при необходимости расширяется чуть больше, чем в полтора раза:

`int newCapacity = (oldCapacity * 3)/2 + 1`

Константа немного больше: 40 (64) байта, так как помимо массива есть ещё сам объект ArrayList, в котором хранится ссылка на массив, фактический размер списка и количество модификаций (для выкидывания ConcurrentModificationException). Конструированный по умолчанию ArrayList без элементов занимает 80 (144) байта.

### LinkedList

Для каждого элемента списка создаётся по одному служебному объекту типа `Entry`. Каждый из этих объектов содержит по три ссылки (на сам элемент списка, на предыдущий и последующий `Entry`), при этом из-за выравнивания в 32bit теряется по 4 байта, поэтому в итоге требуется 24 (40) байт на каждый `Entry`. Константа включает в себя дескриптор объекта LinkedList, головной `Entry` и ссылку на него, размер списка и количество модификаций и равна 48 (80) байт. Столько же занимает пустой список, так как никакой памяти про запас здесь не выделяется.

### Сравнение по времени

ArrayList следует использовать, когда в приоритете доступ по индексу, так как эта операция выполняется за константное время. Добавление в конец списка в среднем тоже выполняется за константное время. Кроме того, в ArrayList нет дополнительных расходов на хранение связки между элементами. Основной минус заключается в скорости вставки / удаления элементов, находящихся не в конце списка, так как при этой операции все элементы правее добавляемого / удаляемого сдвигаются.

LinkedList удобен, когда важнее быстродействие операций вставки / удаления, которые в LinkedList выполняются за константное время. Операции доступа по индексу производятся перебором с начала или конца списка до нужного элемента. Также LinkedList требует дополнительных затрат на хранение связки между элементами.

### Результаты тестов
```
==============Begin==================
---Insert elements to begin (100k)

ArrayList time: 369 ms
ArrayList memory: 3 Mb

LinkedList time: 4 ms
LinkedList memory: 3 Mb

==============Middle=================
---Insert elements to middle (100k)

ArrayList time: 368 ms
ArrayList memory: 2 Mb

LinkedList time: 4 ms
LinkedList memory: 3 Mb

==============End====================
---Insert elements to end (5kk)

ArrayList time: 110 ms
ArrayList memory: 132 Mb

LinkedList time: 392 ms
LinkedList memory: 199 Mb
```