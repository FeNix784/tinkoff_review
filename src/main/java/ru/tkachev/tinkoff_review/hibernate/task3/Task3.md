# Hibernate - Задание №3

### EntityManager, каскадные операции, свойства транзакций<br/><br/>

В Hibernate работа с БД осуществляется через объект типа `org.hibernate.Session`. 
С помощью сессий выполняются все CRUD-операции с объектами-сущностями. 
Объект типа `Session` получают из экземпляра типа `org.hibernate.SessionFactory`, 
который должен присутствовать в приложении в виде `singleton`.

Объект-сущность может находиться в одном из 3-х состояний:

* `transient object` — заполненные экземпляры классов-сущностей, могут быть сохранены 
в БД, не присоединены к сессии, поле `id` не должно быть заполнено, иначе объект имеет статус `detached`;
* `persistent object` — хранимая сущность, которая присоединена к конкретной сессии, 
только в этом статусе объект взаимодействует с базой данных, при работе с объектом 
данного типа в рамках транзакции все изменения объекта записываются в базу;
* `detached object` — объект, отсоединённый от сессии, может существовать или не существовать в БД.

Любой объект-сущность можно переводить из одного статуса в другой. 
Для этого в интерфейсе `Session` существуют следующие методы:


* `persist(Object)` — преобразует объект из `transient` в `persistent`, 
то есть присоединяет к сессии и сохраняет в БД, однако если присвоить некоторое значение 
полю `id` объекта, то получим `PersistentObjectException`, поскольку Hibernate 
посчитает, что объект `detached`, т. е. существует в БД, при сохранении метод 
`persist()` сразу выполняет `insert`, не делая `select`;


* `merge(Object)` — преобразует объект из `transient` или `detached` в `persistent`,
если из `transient`, то работает аналогично `persist()`, т.е. генерирует для объекта 
новый `id`, даже если он задан, если из `detached` — загружает объект из БД, 
присоединяет к сессии, а при сохранении выполняет запрос `update`;


* `replicate(Object, ReplicationMode)` — преобразует объект из `detached` в `persistent`, 
при этом у объекта обязательно должен быть заранее установлен `id`, данный метод 
предназначен для сохранения в БД объекта с заданным `id`, чего не позволяют сделать 
`persist()` и `merge()`, если объект с данным `id` уже существует в БД, 
то поведение определяется согласно правилу из перечисления `org.hibernate.ReplicationMode`:
  * `ReplicationMode.IGNORE` — ничего не меняется в базе;
  * `ReplicationMode.OVERWRITE` — объект сохраняется в базу вместо существующего;
  * `ReplicationMode.LATEST_VERSION` — в базе сохраняется объект с последней версией;
  * `ReplicationMode.EXCEPTION` — генерирует исключение;


* `delete(Object)` — удаляет объект из БД, иными словами, преобразует `persistent`
в `transient`, `Object` может быть в любом статусе, главное, чтобы был установлен `id`;


* `save(Object)` — сохраняет объект в БД, генерируя новый id, даже если он установлен, 
`Object` может быть в статусе `transient` или `detached`;


* `update(Object)` — обновляет объект в БД, преобразуя его в `persistent`,
`Object` в статусе `detached`;


* `saveOrUpdate(Object)` — вызывает `save()` или `update()`;


* `refresh(Object)` — обновляет `detached`-объект, выполнив `select` к БД, 
и преобразует его в `persistent`;


* `get(Object.class, id)` — получает из БД объект класса-сущности с определённым `id` в статусе `persistent`

Объект `Session` кэширует у себя загруженные объекты, при загрузке объекта из БД 
в первую очередь проверяется кэш. Для того чтобы удалить объект из кэша и отсоединить 
от сессии, используется `session.evict(Object)`, а метод `session.clear()` применит 
`evict()` ко всем объектам в сессии.

Рассмотрим две сущности — разработчика `Developer` и его задачи `Task`.

Параметр `fetch` в `@OneToMany` обозначает, когда загружать дочерние объекты. 
Может иметь одно из двух значений, указанных в перечислении 
`javax.persistence.FetchType`:

* `FetchType.EAGER` — загружать коллекцию дочерних объектов сразу же, при загрузке родительских объектов;
* `FetchType.LAZY` — загружать коллекцию дочерних объектов при первом обращении к ней — так называемая отложенная загрузка;

Параметр `cascade` обозначает, какие из методов интерфейса `Session` будут 
распространяться каскадно к ассоциированным сущностям. Например, в классе-сущности 
`Developer` для коллекции `tasks` укажем 

`cascade = {CascadeType.PERSIST, CascadeType.MERGE}`

Тогда при выполнении `session.persist(developer)` или `session.merge(developer)` операции 
`persist` или `merge` будут применены ко всем объектам из `tasks`. 
Аналогично для остальных операций из перечисления `javax.persistence.CascadeType`. 
`CascadeType.ALL` применяет все операции из перечисления.
Необходимо правильно настроить `CascadeType`, дабы не подгружать из базы кучу лишних 
ассоциированных объектов-сущностей.

Транзакции могут управляться следующими способами:

* Программное управление путем написания пользовательского кода (старый способ управления транзакциями), плюсы: границы транзакции
очевидны в коде, минусы: код повторяющийся и подвержен ошибкам, нужно написать множество шаблонов 
(использование `TransactionTemplate` или `PlatformTransactionManager`);
* Декларативное управление транзакциями – отделение управления транзакциями от 
бизнес-логики, использование только аннотаций в конфигурации (аннотация `@Transactional`). 

Аннотация `@Transactional` может быть помещена перед определением интерфейса 
или метода, определением класса или публичным методом класса. Если необходимо, 
чтобы некоторые методы класса (помеченные аннотацией `@Transactional`) имели 
разные настройки атрибутов, такие как уровень изоляции или уровень распространения,
необходимо разместить аннотацию на уровне метода, чтобы переопределить настройки 
атрибутов уровня класса.

В режиме прокси (который установлен по умолчанию) могут быть
перехвачены только «внешние» вызовы метода, идущие через прокси. Это
означает, что «самостоятельный вызов», например метод в целевом объекте,
вызывающий какой-либо другой метод целевого объекта, не приведет к
фактической транзакции во время выполнения даже если вызываемый метод
помечен с `@Transactional`.

Выбор между программным и декларативным управлением транзакциями:
* Программное управление транзакциями – небольшое количество транзакционных операций 
(в большинстве случаев это не транзакции);

* Имя транзакции может быть явно установлено только при программном управлении транзакциями;

* Программное управление транзакциями должно быть использовано когда необходимо 
явно контролировать управление транзакциями;

* Если в приложении содержатся многочисленные транзакционные операции, стоит 
использовать декларативное управление;

* Декларативное управление не позволяет управлять транзакциями в
бизнес-логике и его несложно настроить.

Свойства транзакций:

* `isolation`
  * DEFAULT: использовать уровень изоляции установленный по умолчанию в базовой базе данных;
  * READ_COMMITTED (чтение фиксированных данных): постоянная, указывающая, 
что грязное чтение предотвращено; могут возникать неповторяющееся чтение и фантомное чтение;
  * READ_UNCOMMITTED (чтение незафиксированных данных): этот уровень изоляции 
указывает, что транзакция может считывать данные, которые еще не удалены другими транзакциями;
  * REPEATABLE_READ (повторяемость чтения): Постоянная, указывающая на то, 
что грязное чтение и неповторяемое чтение предотвращаются, может появляться фантомное чтение;
  * SERIALIZABLE (упорядочиваемость): постоянная, указывающая, что грязное чтение, неповторяемое чтение и фантомное чтение предотвращены;

* `timeout`
  * По умолчанию используется таймаут, установленный по умолчанию для базовой транзакционной системы;
  * Сообщает менеджеру tx о продолжительности времени, чтобы дождаться простоя tx, 
прежде чем принять решение об откате не отвечающих транзакций;

* `propagation`
  * REQUIRED: указывает, что целевой метод не может работать без активного tx, 
если tx уже запущен до вызова этого метода, то он будет продолжаться в том же tx, 
или новый tx начнется вскоре после вызова этого метода;
  * REQUIRES_NEW: указывает, что новый tx должен запускаться каждый раз при вызове 
целевого метода, если уже идет tx, он будет приостановлен, прежде чем запускать новый;
  * MANDATORY: указывает, что для целевого метода требуется активный tx, 
если tx не будет продолжаться, он не сработает, выбросив исключение;
  * SUPPORTS: указывает, что целевой метод может выполняться независимо от tx, 
если tx работает, он будет участвовать в том же tx, если выполняется без tx, 
он все равно будет выполняться, если ошибок не будет;
  * NOT_SUPPORTED: указывает, что целевой метод не требует распространения контекста транзакции;
  * NEVER: указывает, что целевой метод вызовет исключение, если выполняется в транзакционном процессе;

* `rollbackFor=Exception.class`
  * Значение по умолчанию: `rollbackFor=RunTimeException.class`;
  * В Spring все классы API бросают `RuntimeException`, это означает, 
что если какой-либо метод не выполняется, контейнер всегда откатывает текущую транзакцию;

* `noRollbackFor=Exception.class`
  * Указывает, что откат не должен происходить, если целевой метод вызывает это исключение.

### Выбор области транзакций, flush и commit, логирование транзакций в Spring<br/><br/>

Spring выполняет логирование практически всех действий с транзакциями: для этого 
надо включить уровень логирования `DEBUG` для пакета `org.springframework.transaction`, 
и при использовании Hibernate - `org.hibernate.transaction`.

Также можно узнать, что происходит с транзакциями программно, обращаясь к 
ThreadLocal переменным
```
TransactionSynchronizationManager.isActualTransactionActive();
TransactionAspectSupport.currentTransactionStatus();
```

Метод `flush()` используется для синхронизации изменений, внесенных в Hibernate сессию 
(объекты в памяти), с базой данных. Однако это не завершает транзакцию,
вместо этого Hibernate отправляет все ожидающие выполнения инструкции SQL в базу данных.
Это полезно, когда необходимо сохранить изменения в базе данных до завершения 
транзакции, например, для обеспечения соблюдения ограничений базы данных 
или для того, чтобы изменения были видны другим транзакциям.

Метод `commit()` используется для завершения транзакции и сохранения всех изменений,
выполненных в рамках транзакции, в базе данных. Если во время операции `commit()` 
возникает ошибка, транзакция может быть откатана и изменения не сохранятся в базе данных.