# Multithreading - Задание №2

### Подумать над задачей параллельного вызова двух систем с агрегацией результата <br/><br/>

В Java 1.8 появился новый класс, который называется `CompletableFuture`. Он реализует интерфейс `Future`, то есть задачи будут выполнены в будущем, после чего можно выполнить метод `get()` и получить результат. Но ещё он реализует некоторый `CompletionStage`, т.е. это некий этап (`Stage`) каких-то вычислений

С помощью `runAsync()` можно запустить в отдельном треде задачу, для которой не требуется возвращать результат, а будет возвращен `CompletableFuture<Void>`

В первом примере просто ждем секунду и печатаем значение, но в отдельном треде, а в основном треде блокируем код до получения результата, но поскольку тип результата `Void`, то просто ждем завершения. Если убрать последнюю строчку, то ничего не напечатается, поскольку программа завершится, не дожидаясь завершения параллельного потока

Во втором примере для возвращения результата из параллельного треда используется метод `supplyAsync()`

Метод `get()` блокирует текущий поток, обычно требуется другое: надо не блокировать текущий поток для получения значения, а задать функцию, которая сделает что-то со значением сразу после того, как оно будет вычислено, в том же параллельном потоке, так называемую `callback`-функцию

Допустим в третьем примере необходимо закончить вычисления в `supplyAsync()` и далее сделать что-то с результатом, не блокируя текущий поток. Метод `supplyAsync()` возвращает строку, необходимо по окончании вычислений длительностью 1 секунда присоединить к результату «example» номер «3»

После вызова `thenApply()` печатаем строку «go further», чтобы убедиться, что `thenApply()` не блокирует код. Только в конце блокируется код, чтобы получить конечный результат методом `get()` и вывести его. Функция внутри `supplyAsync()` и заданный для нее `callback` внутри `thenApply()` не блокируют текущий поток

Если из `callback`-функции значение возвращать не нужно, а необходимо просто что-то сделать в ней, то можно использовать методы `thenRun()` и `thenAccept()`, которые возвращают `CompletableFuture<Void>`

В четвертом примере сервис отдает объект `User`, и когда пользователь получен, выводится его `id`. Метод `thenAccept()` имеет доступ к тому, что получено в `supplyAsync()`, но сам результат не возвращает. Метод `thenRun()` отличается от `thenAccept()` тем, что не имеет доступа к тому, что вычислил `supplyAsync()`

Допустим необходимо получить данные пользователя с помощью внешнего сервиса, а потом получить его кредитный рейтинг. Логично применить метод `thenApply()`, но в предыдущих примерах `callback`-функция, которая запускалась в `thenApply()`, возвращала обычное значение, а не `CompletableFuture`. Теперь же `callback`-функция возвращает `CompletableFuture`, т.е. конечный результат — это вложенный `CompletableFuture`. Если необходимо избавиться от вложенности, то необходимо использовать метод `thenCompose()`, как представлено в пятом примере

С помощью `thenCompose()` комбинировалось два `Future`, в которых один зависел от другого. Метод `thenCombine()` используется, когда надо запустить два независимых `Future` и сделать нечто после того, как оба они завершатся

В шестом примере первый `CompletableFuture` возвращает вес, второй — рост. Когда оба значения получены, рассчитывается индекс массы тела. Он вычисляется в `callback`-функции, переданной в метод `thenCombine()`

Допустим есть список независимых `CompletableFuture`, необходимо их запустить параллельно, а по окончании выполнения всех сделать кое-что еще, для этого можно использовать `CompletableFuture.allOf()`

В седьмом примере необходимо загрузить 10 веб-страниц, загружать требуется их параллельно, то есть каждая страница грузится асинхронно. Когда все страницы загрузятся, требуется посчитать количество страниц, текст которых содержит слово «CompletableFuture». Метод `join()` вызывается тогда, когда все страницы уже будут закачаны, т.е. ничего не блокируется. Метод `join()` такой же как и `get()`, но он выбрасывает `unchecked exception`, если его выбросил `CompletableFuture`
